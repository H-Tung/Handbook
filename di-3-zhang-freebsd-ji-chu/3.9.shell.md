# 3.9.Shell

shell提供了一个与操作系统进行交互的命令行界面。shell从输入通道接收命令并执行它们。许多shell提供了内置的功能来帮助完成日常任务，如文件管理、文件球化、命令行编辑、命令宏和环境变量。FreeBSD有几个shell，包括Bourne shell(sh(1))和扩展C shell(tcsh(1))。其他shell可以从FreeBSD Ports Collection中获得，例如zsh和bash。

所用的shell实际上是一个品味问题。一个C语言程序员可能觉得使用类似C语言的shell更舒服，比如tcsh(1)。一个Linux®用户可能更喜欢bash。每个shell都有独特的属性，可能与用户喜欢的工作环境配合，也可能不配合，这就是为什么要选择使用哪个shell。

一个常见的shell功能是文件名完成。当用户输入一个命令或文件名的前几个字母并按下Tab键后，shell将完成该命令或文件名的其余部分。考虑两个名为foobar和football的文件。要删除foobar，用户可以输入rm foo并按Tab键来完成文件名。

但shell只显示rm foo。它无法完成文件名，因为foobar和football都以foo开头。如果有多个名字匹配，有些shell会发出哔哔声或显示所有的选择。然后用户必须输入更多的字符来确定所需的文件名。输入一个t并再次按Tab键，就足以让shell确定所需的文件名并填入其余部分。

shell的另一个特点是使用环境变量。环境变量是存储在shell环境中的一对变量/键。这个环境可以被shell调用的任何程序所读取，因此包含了很多程序的配置。常见的环境变量提供了一个常见的环境变量的列表和它们的含义。注意，环境变量的名称总是大写的。

表5. 常见的环境变量

|变化的|描述|
|:---:|:---:|
|用户|当前登录的用户的名字。|
|PATH|用冒号分隔的目录列表来搜索二进制文件。|
|显示|要连接的Xorg显示器的网络名称，如果有的话。|
|SHELL|当前的外壳。|
|术语|用户的终端类型的名称。用于确定终端的能力。|
|TERMCAP|在数据库中输入终端转义代码以执行各种终端功能。|
|种类|操作系统的类型。|
|医学上称为MACHTYPE|系统的CPU架构。|
|编辑|用户的首选文本编辑器。|
|PAGER|用户每次查看文本的首选工具。|
|MANPATH|以冒号分隔的目录列表，用于搜索手册页面。|

如何设置环境变量在不同的shell中是不同的。在 tcsh(1) 和 csh(1) 中，使用 setenv 来设置环境变量。在sh(1)和bash中，使用export来设置当前环境变量。这个例子将tcsh(1)shell的默认EDITOR设置为/usr/local/bin/emacs。

>% setenv EDITOR /usr/local/bin/emacs

bash的对应命令是。

>% export EDITOR="/usr/local/bin/emacs"

要展开一个环境变量以查看其当前设置，请在命令行上的名称前输入$字符。例如，echo $TERM显示当前的$TERM设置。

Shell将特殊字符（称为元字符）视为数据的特殊代表。最常见的元字符是*，它代表文件名中的任何数量的字符。元字符可以用来执行文件名球化。例如，echo *等同于ls，因为shell将所有与*相匹配的文件拿出来，echo将它们列在命令行上。

为了防止shell解释一个特殊的字符，可以用反斜杠（\）开头来转义它。例如，echo $TERM打印终端设置，而echo\$TERM则是打印字符串$TERM。

## 3.9.1.改变外壳

永久改变默认shell的最简单方法是使用chsh。运行这个命令将打开在EDITOR环境变量中配置的编辑器，默认情况下，它被设置为vi(1)。将Shell: 一行改为新Shell的完整路径。

另外，使用chsh -s可以在不打开编辑器的情况下设置指定的shell。例如，要把shell改为bash。

>% chsh -s /usr/local/bin/bash

**新的 shell 必须出现在 /etc/shells 中。如果 shell 是按照安装应用程序中描述的从 FreeBSD Ports Collection 安装的。软件包和端口， 它应该被自动添加到这个文件中。如果没有，请用这个命令添加它，用shell的路径代替它的路径。**

># echo /usr/local/bin/bash >> /etc/shells

**然后，重新运行chsh(1)。**

## 3.9.2. 高级外壳技术

UNIX® shell不仅仅是一个命令解释器，它作为一个强大的工具，允许用户执行命令，重定向其输出，重定向其输入，并将命令连锁起来，以提高最终的命令输出。当这种功能与内置的命令混合在一起时，就为用户提供了一个可以使效率最大化的环境。

Shell重定向是将一条命令的输出或输入发送到另一条命令或文件中的行为。例如，要把ls(1)命令的输出抓到一个文件中去，就要把输出重定向。

>% ls > directory_listing.txt

现在目录内容将被列在directory_listing.txt中。有些命令可以用来读取输入，比如sort(1)。要对这个列表进行排序，请重定向输入。

>% sort < directory_listing.txt

输入将被排序并放在屏幕上。为了将该输入重定向到另一个文件，可以通过混合方向来重定向sort(1)的输出。

>% sort < directory_listing.txt > sorted.txt

在前面所有的例子中，命令都是使用文件描述符进行重定向的。每个UNIX®系统都有文件描述符，包括标准输入（stdin）、标准输出（stdout）和标准错误（stderr）。每一个都有一个目的，其中输入可以是键盘或鼠标，是提供输入的东西。输出可以是屏幕或打印机中的纸张。而错误则是任何用于诊断或错误信息的东西。这三个都被认为是基于I/O的文件描述符，有时也被认为是流。

通过使用这些描述符，shell允许输出和输入通过各种命令传递，并重定向到一个文件或从一个文件输出。另一种重定向的方法是管道操作符。

UNIX®管道操作符"|"允许将一个命令的输出直接传递或引导到另一个程序。基本上，管道允许将一个命令的标准输出作为标准输入传递给另一个命令，例如。

>% cat directory_listing.txt | sort | less

在这个例子中，directory_listing.txt的内容将被排序，输出结果传递给less(1)。这使得用户可以按照自己的节奏滚动浏览输出，并防止其滚出屏幕。
